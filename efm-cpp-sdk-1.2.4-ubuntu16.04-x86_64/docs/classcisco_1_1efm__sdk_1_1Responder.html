<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cisco Kinetic EFM IOT C++ SDK: cisco::efm_sdk::Responder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cisco Kinetic EFM IOT C++ SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cisco</b></li><li class="navelem"><b>efm_sdk</b></li><li class="navelem"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcisco_1_1efm__sdk_1_1Responder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cisco::efm_sdk::Responder Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the responder part of a link.  
 <a href="classcisco_1_1efm__sdk_1_1Responder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="efm__responder_8h_source.html">efm_responder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a145dafa02f0c401360ce76ab4b035fa7"><td class="memItemLeft" align="right" valign="top"><a id="a145dafa02f0c401360ce76ab4b035fa7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a145dafa02f0c401360ce76ab4b035fa7">Responder</a> (<a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a145dafa02f0c401360ce76ab4b035fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not movable. <br /></td></tr>
<tr class="separator:a145dafa02f0c401360ce76ab4b035fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819749e9ebaff65baf9d99f77719051c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a819749e9ebaff65baf9d99f77719051c">operator=</a> (<a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a819749e9ebaff65baf9d99f77719051c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not move assignable.  <a href="#a819749e9ebaff65baf9d99f77719051c">More...</a><br /></td></tr>
<tr class="separator:a819749e9ebaff65baf9d99f77719051c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c2ef45b3f813286745c97578e12825"><td class="memItemLeft" align="right" valign="top"><a id="ae7c2ef45b3f813286745c97578e12825"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#ae7c2ef45b3f813286745c97578e12825">Responder</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;)=delete</td></tr>
<tr class="memdesc:ae7c2ef45b3f813286745c97578e12825"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:ae7c2ef45b3f813286745c97578e12825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3dc27300eeb2d13f777d1c854b7a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#adb3dc27300eeb2d13f777d1c854b7a47">operator=</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;)=delete</td></tr>
<tr class="memdesc:adb3dc27300eeb2d13f777d1c854b7a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not assignable.  <a href="#adb3dc27300eeb2d13f777d1c854b7a47">More...</a><br /></td></tr>
<tr class="separator:adb3dc27300eeb2d13f777d1c854b7a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ca4efa931cb12309136d989f76cfe"><td class="memItemLeft" align="right" valign="top"><a id="adc8ca4efa931cb12309136d989f76cfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#adc8ca4efa931cb12309136d989f76cfe">~Responder</a> ()</td></tr>
<tr class="memdesc:adc8ca4efa931cb12309136d989f76cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html" title="This is the responder part of a link. ">Responder</a> object. <br /></td></tr>
<tr class="separator:adc8ca4efa931cb12309136d989f76cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c198a17c73e42eb19ad82574951046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a22c198a17c73e42eb19ad82574951046">add_node_creation_callback</a> (const std::string &amp;path_pattern, std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;, <a class="el" href="efm__types_8h.html#aa741ecd03b4592d31cd924a18998e55b">NodeCreationContext</a> context, const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a22c198a17c73e42eb19ad82574951046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback for a path pattern.  <a href="#a22c198a17c73e42eb19ad82574951046">More...</a><br /></td></tr>
<tr class="separator:a22c198a17c73e42eb19ad82574951046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ae298ed63aa0e632c77d5413cab081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a23ae298ed63aa0e632c77d5413cab081">remove_node_creation_callback</a> (const std::string &amp;path_pattern)</td></tr>
<tr class="memdesc:a23ae298ed63aa0e632c77d5413cab081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added callback for a path pattern.  <a href="#a23ae298ed63aa0e632c77d5413cab081">More...</a><br /></td></tr>
<tr class="separator:a23ae298ed63aa0e632c77d5413cab081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367eda651d4bb0f36b5c0c22484829a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a367eda651d4bb0f36b5c0c22484829a6">register_callback</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, <a class="el" href="efm__types_8h.html#ac74501adc46f630e9bb69248aad8d6e5">CallbackOn</a> callback_on, std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;, <a class="el" href="efm__types_8h.html#ac74501adc46f630e9bb69248aad8d6e5">CallbackOn</a>)&gt; &amp;&amp;responder_callback)</td></tr>
<tr class="memdesc:a367eda651d4bb0f36b5c0c22484829a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback for a distinct event on the responder.  <a href="#a367eda651d4bb0f36b5c0c22484829a6">More...</a><br /></td></tr>
<tr class="separator:a367eda651d4bb0f36b5c0c22484829a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7374df4300ab357f1c82152c71a8d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#adc7374df4300ab357f1c82152c71a8d8">unregister_callback</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, <a class="el" href="efm__types_8h.html#ac74501adc46f630e9bb69248aad8d6e5">CallbackOn</a> callback_on)</td></tr>
<tr class="memdesc:adc7374df4300ab357f1c82152c71a8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a previously registered callback.  <a href="#adc7374df4300ab357f1c82152c71a8d8">More...</a><br /></td></tr>
<tr class="separator:adc7374df4300ab357f1c82152c71a8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fe99bbd36e702d8cab161fd0602ee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#ac0fe99bbd36e702d8cab161fd0602ee0">add_node</a> (<a class="el" href="classcisco_1_1efm__sdk_1_1NodeBuilder.html">NodeBuilder</a> &amp;&amp;builder, std::function&lt; void(const std::vector&lt; <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &gt; &amp;, const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac0fe99bbd36e702d8cab161fd0602ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add asynchronously the nodes described by the given <a class="el" href="classcisco_1_1efm__sdk_1_1NodeBuilder.html" title="Defines the structure of new nodes to add to a responder. ">NodeBuilder</a> to the responders node model.  <a href="#ac0fe99bbd36e702d8cab161fd0602ee0">More...</a><br /></td></tr>
<tr class="separator:ac0fe99bbd36e702d8cab161fd0602ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbc810c8c8f68ff354ed40aab0d16c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a4cbc810c8c8f68ff354ed40aab0d16c4">remove_node</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a4cbc810c8c8f68ff354ed40aab0d16c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove asynchronously the given path from the responders node model.  <a href="#a4cbc810c8c8f68ff354ed40aab0d16c4">More...</a><br /></td></tr>
<tr class="separator:a4cbc810c8c8f68ff354ed40aab0d16c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26d3222fc001ac330239e33be0c83f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#af26d3222fc001ac330239e33be0c83f6">update_node</a> (<a class="el" href="classcisco_1_1efm__sdk_1_1NodeUpdater.html">NodeUpdater</a> &amp;&amp;updater, std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:af26d3222fc001ac330239e33be0c83f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a nodes metadata asynchronously.  <a href="#af26d3222fc001ac330239e33be0c83f6">More...</a><br /></td></tr>
<tr class="separator:af26d3222fc001ac330239e33be0c83f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34719b11a5a92766b5d2030acfd09e75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a34719b11a5a92766b5d2030acfd09e75">exists</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path) const</td></tr>
<tr class="memdesc:a34719b11a5a92766b5d2030acfd09e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given path exists.  <a href="#a34719b11a5a92766b5d2030acfd09e75">More...</a><br /></td></tr>
<tr class="separator:a34719b11a5a92766b5d2030acfd09e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41301ae60481dc603146ef14dc61acbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a41301ae60481dc603146ef14dc61acbe">enumerate_children</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;parent_path, std::function&lt; void(const std::vector&lt; <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &gt; &amp;, const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a41301ae60481dc603146ef14dc61acbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve asynchronously the paths of the children of the given parent path if any available.  <a href="#a41301ae60481dc603146ef14dc61acbe">More...</a><br /></td></tr>
<tr class="separator:a41301ae60481dc603146ef14dc61acbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd0918139a20bb61ab00b856560d2b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a5bd0918139a20bb61ab00b856560d2b7">get_value</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, const std::error_code &amp;ec)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a5bd0918139a20bb61ab00b856560d2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve asynchronously the value of the given path.  <a href="#a5bd0918139a20bb61ab00b856560d2b7">More...</a><br /></td></tr>
<tr class="separator:a5bd0918139a20bb61ab00b856560d2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a68b9440164bec2a2d7d09e2893aa42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a2a68b9440164bec2a2d7d09e2893aa42">set_value</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;&amp;value, const std::chrono::system_clock::time_point &amp;timestamp, std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a2a68b9440164bec2a2d7d09e2893aa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the value for the given path.  <a href="#a2a68b9440164bec2a2d7d09e2893aa42">More...</a><br /></td></tr>
<tr class="separator:a2a68b9440164bec2a2d7d09e2893aa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a2b0c7a90bfcdb804caf781bcd1fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a76a2b0c7a90bfcdb804caf781bcd1fbb">set_value</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, const std::chrono::system_clock::time_point &amp;timestamp, std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a76a2b0c7a90bfcdb804caf781bcd1fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the value for the given path.  <a href="#a76a2b0c7a90bfcdb804caf781bcd1fbb">More...</a><br /></td></tr>
<tr class="separator:a76a2b0c7a90bfcdb804caf781bcd1fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513bb3e3a1f4f64a8f2c8b99a0f296fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a513bb3e3a1f4f64a8f2c8b99a0f296fe">set_value</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;&amp;value, std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a513bb3e3a1f4f64a8f2c8b99a0f296fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the value for the given path.  <a href="#a513bb3e3a1f4f64a8f2c8b99a0f296fe">More...</a><br /></td></tr>
<tr class="separator:a513bb3e3a1f4f64a8f2c8b99a0f296fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aee75e19e72c5a9a4e9802cea29c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a71aee75e19e72c5a9a4e9802cea29c30">set_value</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a71aee75e19e72c5a9a4e9802cea29c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the value for the given path.  <a href="#a71aee75e19e72c5a9a4e9802cea29c30">More...</a><br /></td></tr>
<tr class="separator:a71aee75e19e72c5a9a4e9802cea29c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab4222e60fbd17e5296932f33b1cfeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a9ab4222e60fbd17e5296932f33b1cfeb">get_config</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, const std::string &amp;config_name, std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, const std::error_code &amp;ec)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a9ab4222e60fbd17e5296932f33b1cfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve asynchronously the config value of the given path.  <a href="#a9ab4222e60fbd17e5296932f33b1cfeb">More...</a><br /></td></tr>
<tr class="separator:a9ab4222e60fbd17e5296932f33b1cfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fee2e34ff05b0fab499ca3888a8662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#aa5fee2e34ff05b0fab499ca3888a8662">get_attribute</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, const std::string &amp;attribute_name, std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, const std::error_code &amp;ec)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:aa5fee2e34ff05b0fab499ca3888a8662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve asynchronously the attribute value of the given path.  <a href="#aa5fee2e34ff05b0fab499ca3888a8662">More...</a><br /></td></tr>
<tr class="separator:aa5fee2e34ff05b0fab499ca3888a8662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d4417e031c5d3ed4140d7717d0ef2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#a59d4417e031c5d3ed4140d7717d0ef2c">get_node_info</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;path, std::function&lt; void(const <a class="el" href="structcisco_1_1efm__sdk_1_1NodeInfo.html">NodeInfo</a> &amp;node_info, const std::error_code &amp;ec)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:a59d4417e031c5d3ed4140d7717d0ef2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve asynchronously all information a node provides by a given path.  <a href="#a59d4417e031c5d3ed4140d7717d0ef2c">More...</a><br /></td></tr>
<tr class="separator:a59d4417e031c5d3ed4140d7717d0ef2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a63a18c693f0052f2c0ca45aa9b88f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html#ab9a63a18c693f0052f2c0ca45aa9b88f">create_node_or_set_value</a> (const <a class="el" href="classcisco_1_1efm__sdk_1_1NodeCreateOrSetValueDescription.html">NodeCreateOrSetValueDescription</a> &amp;desc, std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;link_path, const std::error_code &amp;ec)&gt; &amp;&amp;callback)</td></tr>
<tr class="memdesc:ab9a63a18c693f0052f2c0ca45aa9b88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a node if it doesn't exist or set a new value on specified node asynchronously.  <a href="#ab9a63a18c693f0052f2c0ca45aa9b88f">More...</a><br /></td></tr>
<tr class="separator:ab9a63a18c693f0052f2c0ca45aa9b88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the responder part of a link. </p>
<p>It is used to add and manipulate nodes of the responder node model. The <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html" title="This is the responder part of a link. ">Responder</a> will respond to requests originating from requesters. It will also asynchronously push value and list updates to subscribers. The <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html" title="This is the responder part of a link. ">Responder</a> object will be created and managed by the <a class="el" href="classcisco_1_1efm__sdk_1_1Link.html" title="This is the main entry point for a link implementation. ">cisco::efm_sdk::Link</a> instance. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0fe99bbd36e702d8cab161fd0602ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fe99bbd36e702d8cab161fd0602ee0">&#9670;&nbsp;</a></span>add_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcisco_1_1efm__sdk_1_1NodeBuilder.html">NodeBuilder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::vector&lt; <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &gt; &amp;, const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add asynchronously the nodes described by the given <a class="el" href="classcisco_1_1efm__sdk_1_1NodeBuilder.html" title="Defines the structure of new nodes to add to a responder. ">NodeBuilder</a> to the responders node model. </p>
<p>If the nodes cannot be added (i.e. the parent path does not exist), the callback will issue a corresponding error code. If successful, the callback will return all newly created paths. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">builder</td><td>The node descriptions to add. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the add node operation has finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22c198a17c73e42eb19ad82574951046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c198a17c73e42eb19ad82574951046">&#9670;&nbsp;</a></span>add_node_creation_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cisco::efm_sdk::Responder::add_node_creation_callback </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;, <a class="el" href="efm__types_8h.html#aa741ecd03b4592d31cd924a18998e55b">NodeCreationContext</a> context, const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a callback for a path pattern. </p>
<p>Every time a node is created with a path that matches the path pattern, the callback will be called. The callback will provide the nodes path and an error code as parameter to the call.This is useful for example to add action nodes to nodes that are deserialized. The path pattern is used to identify the entry. If a path pattern already exists, it will be overwritten by the last call. Adding a pattern that only matches the root path "/" will have no effect. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_pattern</td><td>The path pattern to match. Follows the DQL syntax for wildcards. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback to call if the path of a created node matches the pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the callback could be added, false if the path pattern was invalid. </dd></dl>

</div>
</div>
<a id="ab9a63a18c693f0052f2c0ca45aa9b88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a63a18c693f0052f2c0ca45aa9b88f">&#9670;&nbsp;</a></span>create_node_or_set_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::create_node_or_set_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodeCreateOrSetValueDescription.html">NodeCreateOrSetValueDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;link_path, const std::error_code &amp;ec)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a node if it doesn't exist or set a new value on specified node asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Information about the node to create or a value to set on the specified node. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the get node info operation has finished. If the error code flags no error, the link_path contains the path of the node. If the error code indicates an error, the link_path contains the path where the error occurs. even if that path doesn't exist. The rest of the node_info structure will be filled with default values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41301ae60481dc603146ef14dc61acbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41301ae60481dc603146ef14dc61acbe">&#9670;&nbsp;</a></span>enumerate_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::enumerate_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::vector&lt; <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &gt; &amp;, const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve asynchronously the paths of the children of the given parent path if any available. </p>
<p>If the node does not exist, the callback will return a corresponding error code. If successful, the callback will return the child paths. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_path</td><td>The path to return the children for. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the enumerate children operation has finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34719b11a5a92766b5d2030acfd09e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34719b11a5a92766b5d2030acfd09e75">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cisco::efm_sdk::Responder::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given path exists. </p>
<p>As the SDK works in an asynchronous way, the existence of a path can only be a snapshot of the current status while calling this method. Upon returning from this method, the status can change anytime asynchronously, including before checking the return value of this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the path exists, otherwise false. </dd></dl>

</div>
</div>
<a id="aa5fee2e34ff05b0fab499ca3888a8662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fee2e34ff05b0fab499ca3888a8662">&#9670;&nbsp;</a></span>get_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::get_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, const std::error_code &amp;ec)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve asynchronously the attribute value of the given path. </p>
<p>If no attribute value exists for the path, the callback will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to retrieve the attribute value for. </td></tr>
    <tr><td class="paramname">attribute_name</td><td>The name of the attribute value to retrieve. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the get attribute operation has finished. If the error code flags no error, the value will be set to the current value of the attribute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab4222e60fbd17e5296932f33b1cfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab4222e60fbd17e5296932f33b1cfeb">&#9670;&nbsp;</a></span>get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::get_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, const std::error_code &amp;ec)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve asynchronously the config value of the given path. </p>
<p>If no config value exists for the path, the callback will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to retrieve the config value for. </td></tr>
    <tr><td class="paramname">config_name</td><td>The name of the config value to retrieve. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the get config operation has finished. If the error code flags no error, the value will be set to the current value of the config. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59d4417e031c5d3ed4140d7717d0ef2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d4417e031c5d3ed4140d7717d0ef2c">&#9670;&nbsp;</a></span>get_node_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::get_node_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structcisco_1_1efm__sdk_1_1NodeInfo.html">NodeInfo</a> &amp;node_info, const std::error_code &amp;ec)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve asynchronously all information a node provides by a given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to retrieve the information for. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the get node info operation has finished. If the error code flags no error, the node_info value contains all information the requested node provides. If the error code indicates an error, the node_info passed into the callback will contain the path given to the get_node_info call, even if that path doesn't exist. The rest of the node_info structure will be filled with default values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bd0918139a20bb61ab00b856560d2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd0918139a20bb61ab00b856560d2b7">&#9670;&nbsp;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;value, const std::error_code &amp;ec)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve asynchronously the value of the given path. </p>
<p>If no value exists for the path, the callback will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to retrieve the value for. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the get value operation has finished. If the error code flags no error, the value will be set to the current value of the path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a819749e9ebaff65baf9d99f77719051c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819749e9ebaff65baf9d99f77719051c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a>&amp; cisco::efm_sdk::Responder::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This class is not move assignable. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html" title="This is the responder part of a link. ">Responder</a> object </dd></dl>

</div>
</div>
<a id="adb3dc27300eeb2d13f777d1c854b7a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3dc27300eeb2d13f777d1c854b7a47">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a>&amp; cisco::efm_sdk::Responder::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html">Responder</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This class is not assignable. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcisco_1_1efm__sdk_1_1Responder.html" title="This is the responder part of a link. ">Responder</a> object </dd></dl>

</div>
</div>
<a id="a367eda651d4bb0f36b5c0c22484829a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367eda651d4bb0f36b5c0c22484829a6">&#9670;&nbsp;</a></span>register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::register_callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="efm__types_8h.html#ac74501adc46f630e9bb69248aad8d6e5">CallbackOn</a>&#160;</td>
          <td class="paramname"><em>callback_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;, <a class="el" href="efm__types_8h.html#ac74501adc46f630e9bb69248aad8d6e5">CallbackOn</a>)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>responder_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback for a distinct event on the responder. </p>
<dl class="section note"><dt>Note</dt><dd>When called with the same path/callback_on twice the second call will replace the previous one. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The node path the event might happen on. </td></tr>
    <tr><td class="paramname">callback_on</td><td>The responder event to listen on. </td></tr>
    <tr><td class="paramname">responder_callback</td><td>The callback will be called when the specified event happened on the given path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cbc810c8c8f68ff354ed40aab0d16c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbc810c8c8f68ff354ed40aab0d16c4">&#9670;&nbsp;</a></span>remove_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove asynchronously the given path from the responders node model. </p>
<p>All child nodes of the node pointed by the path will also be removed. If the path can't be removed (the path doesn't exist), the callback will return a corresponding error code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to remove. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the remove node operation has finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23ae298ed63aa0e632c77d5413cab081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ae298ed63aa0e632c77d5413cab081">&#9670;&nbsp;</a></span>remove_node_creation_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::remove_node_creation_callback </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a previously added callback for a path pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_pattern</td><td>the path pattern to remove the callback for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a68b9440164bec2a2d7d09e2893aa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a68b9440164bec2a2d7d09e2893aa42">&#9670;&nbsp;</a></span>set_value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::set_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::system_clock::time_point &amp;&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the value for the given path. </p>
<p>If no value for the path exists, the callback will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to set the value for. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
    <tr><td class="paramname">timestamp</td><td>The timestamp of the values actual update time. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the set value operation has finished. If the error code flags no error, the node value will be set to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76a2b0c7a90bfcdb804caf781bcd1fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a2b0c7a90bfcdb804caf781bcd1fbb">&#9670;&nbsp;</a></span>set_value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::set_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::system_clock::time_point &amp;&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the value for the given path. </p>
<p>If no value for the path exists, the callback will return an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to set the value for. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
    <tr><td class="paramname">timestamp</td><td>The timestamp of the values actual update time. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the set value operation has finished. If the error code flags no error, the node value will be set to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a513bb3e3a1f4f64a8f2c8b99a0f296fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513bb3e3a1f4f64a8f2c8b99a0f296fe">&#9670;&nbsp;</a></span>set_value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::set_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the value for the given path. </p>
<p>If no value for the path exists, the callback will return an error. The timestamp of the value will be set to the current date and time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to set the value for. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the set value operation has finished. If the error code flags no error, the node value will be set to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71aee75e19e72c5a9a4e9802cea29c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71aee75e19e72c5a9a4e9802cea29c30">&#9670;&nbsp;</a></span>set_value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::set_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1VariantBase.html">Variant</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the value for the given path. </p>
<p>If no value for the path exists, the callback will return an error. The timestamp of the value will be set to the current date and time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the node to set the value for. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the set value operation has finished. If the error code flags no error, the node value will be set to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc7374df4300ab357f1c82152c71a8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7374df4300ab357f1c82152c71a8d8">&#9670;&nbsp;</a></span>unregister_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::unregister_callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcisco_1_1efm__sdk_1_1NodePath.html">NodePath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="efm__types_8h.html#ac74501adc46f630e9bb69248aad8d6e5">CallbackOn</a>&#160;</td>
          <td class="paramname"><em>callback_on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a previously registered callback. </p>
<dl class="section note"><dt>Note</dt><dd>When no callback was registered with the specified path/callback_on nothing will happen </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The node path the event might happen on. </td></tr>
    <tr><td class="paramname">callback_on</td><td>The responder event to listen on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af26d3222fc001ac330239e33be0c83f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26d3222fc001ac330239e33be0c83f6">&#9670;&nbsp;</a></span>update_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cisco::efm_sdk::Responder::update_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcisco_1_1efm__sdk_1_1NodeUpdater.html">NodeUpdater</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>updater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::error_code &amp;)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a nodes metadata asynchronously. </p>
<p>The path to the node is specified by the <a class="el" href="classcisco_1_1efm__sdk_1_1NodeUpdater.html" title="Defines the structure of a node metadata update of an existing responder node. ">NodeUpdater</a>. If the node does not exist, the callback will return a corresponding error code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updater</td><td>The node metadata changes to execute on the node. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback will be called as soon as the update node operation has finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/parstream-ci.gen/workspace/EFM_sdk-dslink-cpp_release_1.2/include/<a class="el" href="efm__responder_8h_source.html">efm_responder.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
COPYRIGHT  2018 CISCO SYSTEMS, INC. ALL RIGHTS RESERVED.
</small></address>
</body>
</html>
